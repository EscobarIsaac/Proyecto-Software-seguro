#!/usr/bin/env python3
"""
Pruebas unitarias para el sistema de detecci√≥n de vulnerabilidades
Proyecto: Pipeline CI/CD Seguro con ML

test_model.py
"""

import pytest
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score
import os
import sys

# Agregar directorio ra√≠z al path
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

class TestVulnerabilityModel:
    """Pruebas del modelo de detecci√≥n de vulnerabilidades"""
    
    @pytest.fixture
    def model_and_data(self):
        """Fixture que carga el modelo y los datos"""
        # Cargar datos de entrenamiento
        train_df = pd.read_csv("train_features.csv", header=None)
        X_train = train_df.iloc[:, :-1]
        y_train = train_df.iloc[:, -1]
        
        # Entrenar modelo
        model = RandomForestClassifier(
            n_estimators=50,
            min_samples_leaf=5,
            random_state=42
        )
        model.fit(X_train, y_train)
        
        return {
            'model': model,
            'X_train': X_train,
            'y_train': y_train
        }
    
    def test_model_accuracy_requirement(self, model_and_data):
        """
        TEST CR√çTICO: Validar que el modelo cumple con accuracy m√≠nimo de 82%
        Requisito del documento: "Accuracy m√≠nima demostrada: 82%"
        """
        model = model_and_data['model']
        X_train = model_and_data['X_train']
        y_train = model_and_data['y_train']
        
        # Calcular accuracy con validaci√≥n cruzada
        cv_scores = cross_val_score(model, X_train, y_train, cv=5, scoring='accuracy')
        mean_accuracy = cv_scores.mean()
        
        print(f"\nüìä Accuracy con validaci√≥n cruzada 5-fold: {mean_accuracy:.4f}")
        print(f"   Scores individuales: {cv_scores}")
        print(f"   Desviaci√≥n est√°ndar: {cv_scores.std():.4f}")
        
        # VALIDACI√ìN CR√çTICA: Debe ser >= 82%
        assert mean_accuracy >= 0.82, f"Accuracy {mean_accuracy:.2%} es menor al 82% requerido"
        print(f"   ‚úÖ CUMPLE: Accuracy {mean_accuracy:.2%} >= 82%")
    
    def test_model_training_accuracy(self, model_and_data):
        """Validar accuracy en datos de entrenamiento"""
        model = model_and_data['model']
        X_train = model_and_data['X_train']
        y_train = model_and_data['y_train']
        
        train_accuracy = model.score(X_train, y_train)
        
        print(f"\nüìä Accuracy en datos de entrenamiento: {train_accuracy:.4f}")
        
        # El accuracy en training deber√≠a ser alto
        assert train_accuracy >= 0.80, f"Accuracy muy bajo en training: {train_accuracy:.2%}"
        print(f"   ‚úÖ Training accuracy: {train_accuracy:.2%}")
    
    def test_model_prediction_format(self, model_and_data):
        """Validar formato de predicciones del modelo"""
        model = model_and_data['model']
        X_train = model_and_data['X_train']
        
        # Tomar una muestra
        X_sample = X_train.iloc[:5]
        
        # Predecir
        predictions = model.predict(X_sample)
        probabilities = model.predict_proba(X_sample)
        
        # Validar formato
        assert len(predictions) == 5, "N√∫mero de predicciones incorrecto"
        assert probabilities.shape == (5, 2), "Shape de probabilidades incorrecto"
        assert all(p in [0, 1] for p in predictions), "Predicciones deben ser 0 o 1"
        
        print("\n‚úÖ Formato de predicciones correcto")
    
    def test_feature_extraction(self):
        """Validar extracci√≥n de caracter√≠sticas"""
        from preprocesar_vulnerabilidades import extract_features
        
        # C√≥digo vulnerable (SQL injection)
        vulnerable_code = "query = 'SELECT * FROM users WHERE id = ' + user_input"
        features_vulnerable = extract_features(vulnerable_code)
        
        # C√≥digo seguro
        safe_code = "x = 5 + 3"
        features_safe = extract_features(safe_code)
        
        # Validar que se extraen 12 caracter√≠sticas (sin score)
        assert len(features_vulnerable) == 12, "Debe extraer 12 caracter√≠sticas"
        assert len(features_safe) == 12, "Debe extraer 12 caracter√≠sticas"
        
        # El c√≥digo vulnerable debe tener mayor sql_risk
        assert features_vulnerable.iloc[7] > features_safe.iloc[7], "SQL risk no detectado"
        
        print("\n‚úÖ Extracci√≥n de caracter√≠sticas funciona correctamente")
    
    def test_alert_levels(self, model_and_data):
        """Validar sistema de alertas por probabilidad"""
        model = model_and_data['model']
        X_train = model_and_data['X_train']
        
        # Predecir probabilidades
        probabilities = model.predict_proba(X_train)
        
        # Contar alertas por nivel
        critical = sum(probabilities[:, 1] > 0.70)
        medium = sum((probabilities[:, 1] > 0.50) & (probabilities[:, 1] <= 0.70))
        low = sum(probabilities[:, 1] <= 0.50)
        
        print(f"\nüìä Distribuci√≥n de alertas:")
        print(f"   üö® Cr√≠ticas (>70%): {critical}")
        print(f"   ‚ö†Ô∏è  Medias (50-70%): {medium}")
        print(f"   ‚úÖ Bajas (<50%): {low}")
        
        # Validar que el sistema puede detectar diferentes niveles
        assert critical + medium + low == len(X_train), "Suma de alertas incorrecta"
        print("   ‚úÖ Sistema de alertas funciona correctamente")


class TestFeatureExtraction:
    """Pruebas de extracci√≥n de caracter√≠sticas"""
    
    def test_sql_injection_detection(self):
        """Detectar patrones de inyecci√≥n SQL"""
        from preprocesar_vulnerabilidades import extract_features
        
        sql_code = """
        user_id = request.GET['id']
        query = "SELECT * FROM users WHERE id = " + user_id
        cursor.execute(query)
        """
        
        features = extract_features(sql_code)
        
        # √çndice 7 es sql_risk
        assert features.iloc[7] > 0, "No detect√≥ patrones SQL"
        print("\n‚úÖ Detecci√≥n de SQL injection funciona")
    
    def test_xss_detection(self):
        """Detectar patrones XSS"""
        from preprocesar_vulnerabilidades import extract_features
        
        xss_code = """
        var userInput = getUserInput();
        document.getElementById('output').innerHTML = userInput;
        """
        
        features = extract_features(xss_code)
        
        # √çndice 8 es xss_risk
        assert features.iloc[8] > 0, "No detect√≥ patrones XSS"
        print("\n‚úÖ Detecci√≥n de XSS funciona")
    
    def test_dangerous_functions_detection(self):
        """Detectar funciones peligrosas"""
        from preprocesar_vulnerabilidades import extract_features
        
        dangerous_code = """
        char buffer[64];
        gets(buffer);
        strcpy(dest, buffer);
        """
        
        features = extract_features(dangerous_code)
        
        # √çndice 10 es dangerous_count
        assert features.iloc[10] > 0, "No detect√≥ funciones peligrosas"
        print("\n‚úÖ Detecci√≥n de funciones peligrosas funciona")


class TestAPIEndpoints:
    """Pruebas de la API Flask"""
    
    @pytest.fixture
    def client(self):
        """Fixture para cliente de pruebas Flask"""
        from app import app
        app.config['TESTING'] = True
        with app.test_client() as client:
            yield client
    
    def test_health_endpoint(self, client):
        """Probar endpoint de salud"""
        response = client.get('/health')
        assert response.status_code == 200
        
        data = response.get_json()
        assert 'status' in data
        assert data['status'] == 'healthy'
        
        print("\n‚úÖ Endpoint /health funciona")
    
    def test_analyze_endpoint_vulnerable(self, client):
        """Probar an√°lisis de c√≥digo vulnerable"""
        vulnerable_code = "query = 'SELECT * FROM users WHERE id = ' + user_input"
        
        response = client.post('/analyze', json={'code': vulnerable_code})
        assert response.status_code == 200
        
        data = response.get_json()
        assert 'prediction' in data
        assert 'prob_vulnerable' in data
        assert 'alert_level' in data
        
        print(f"\n‚úÖ An√°lisis de c√≥digo vulnerable: {data['alert_level']}")
    
    def test_analyze_endpoint_safe(self, client):
        """Probar an√°lisis de c√≥digo seguro"""
        safe_code = "x = 5 + 3\nprint(x)"
        
        response = client.post('/analyze', json={'code': safe_code})
        assert response.status_code == 200
        
        data = response.get_json()
        assert data['prob_vulnerable'] < 0.5
        
        print(f"\n‚úÖ An√°lisis de c√≥digo seguro: {data['alert_level']}")


class TestPipelineIntegration:
    """Pruebas de integraci√≥n del pipeline"""
    
    def test_files_exist(self):
        """Validar que existen todos los archivos necesarios"""
        required_files = [
            'train_features.csv',
            'test_features.csv',
            'preprocesar_vulnerabilidades.py',
            'demo_vulnerabilities.py',
            'app.py',
            'Dockerfile',
            'requirements.txt'
        ]
        
        missing_files = []
        for file in required_files:
            if not os.path.exists(file):
                missing_files.append(file)
        
        assert len(missing_files) == 0, f"Archivos faltantes: {missing_files}"
        print(f"\n‚úÖ Todos los archivos requeridos existen")
    
    def test_dataset_format(self):
        """Validar formato del dataset"""
        train_df = pd.read_csv("train_features.csv", header=None)
        
        # Debe tener 13 caracter√≠sticas + 1 label
        assert train_df.shape[1] == 14, f"Dataset debe tener 14 columnas, tiene {train_df.shape[1]}"
        
        # Labels deben ser 0 o 1
        labels = train_df.iloc[:, -1].unique()
        assert set(labels).issubset({0, 1}), "Labels deben ser 0 o 1"
        
        print(f"\n‚úÖ Dataset tiene formato correcto: {train_df.shape[0]} muestras, {train_df.shape[1]} columnas")


def run_all_tests():
    """Ejecutar todas las pruebas y mostrar resumen"""
    print("=" * 70)
    print("üß™ EJECUTANDO SUITE COMPLETA DE PRUEBAS")
    print("=" * 70)
    
    # Ejecutar pytest
    exit_code = pytest.main([
        __file__,
        '-v',
        '--tb=short',
        '--color=yes'
    ])
    
    print("\n" + "=" * 70)
    if exit_code == 0:
        print("‚úÖ TODAS LAS PRUEBAS PASARON")
    else:
        print("‚ùå ALGUNAS PRUEBAS FALLARON")
    print("=" * 70)
    
    return exit_code


if __name__ == '__main__':
    exit(run_all_tests())
